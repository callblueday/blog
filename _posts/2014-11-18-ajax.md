---
layout: post
title:  "ajax 初探"
date:   2014-11-18 10:03:40
categories: code
---

本文主体内容翻译自：[https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started](https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started)

什么是ajax
-----------
AJAX 就是 Asynchronous JavaScript and XML 的简称。实际上就是 XMLHttpRequest 对象与服务器进行通信的一种方法。

它有两大特点：

    1. 可以在不重新加载页面的情况下向服务器发送请求
    2. 从服务器接收和处理数据

步骤一：创建一个http请求
------------------------
1. 创建一个 HTTP 请求对象

    IE最开始使用名为XMLHTTP的ActiveX对象来创建请求。之后，Mozilla，Safari以及其他的浏览器相继跟上，引入了 XMLHttpRequest 类来实现ActiveX对象的属性和方法。因此，创建一个跨浏览器的请求对象，代码如下：

        var httpRequest;
        if (window.XMLHttpRequest) { // Mozilla, Safari, ...
            httpRequest = new XMLHttpRequest();
        } else if (window.ActiveXObject) { // IE 8 and older
            httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }

2. 定义请求状态改变时，对应的响应事件

        httpRequest.onreadystatechange = nameOfTheFunction;

    注意，该函数后面是没有括号的，因为我们只是在传递一个函数的引用，而非调用。
    或者我们也可以直接在后面定义匿名函数
        ```
        httpRequest.onreadystatechange = function(){
            // process the server response
        };
        ```

3. 发出请求
    定义了接收到服务器反馈后的响应动作，接着你需要实际向服务器发送出这个请求。主要使用HTTP请求类的 open() 和 send() 方法。
    
    ```
    httpRequest.open('GET', 'http://www.example.org/some.file', true);
    httpRequest.send(null);
    ```
    
    open() 方法中的参数说明
    - 参数1：任意你所使用的服务端支持的请求方法，像GET,POST,HEAD都可以。遵循HTTP标准，这些方法名都使用大写。否则某些浏览器（像火狐）会无法执行该请求。详细参考[W3C specs](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)
    - 参数2：你所请求的页面地址，需要使用绝对路径，否则将会被拒绝访问。如果你需要跨域请求，参考[HTTP access control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
    - 参数3：true/false。可选参数，默认值是true。它用来设置该请求是否是异步的。如果值为true，那么在服务器的请求还没有被响应的时候，javascript的函数依然会继续执行。如果值为false，那么函数将会在服务器响应后再执行。

    如果请求方式是POST，send的参数，可以是任意数据。发送有格式的数据在服务器端将会被更容易的进行解析。例如一个查询的字符串。

        "name=value&anothername="+encodeURIComponent(myVar)+"&so=on"

    也可以用其他格式，例如：JSON, SOAP等。

    如果使用的是POST方式，需要设置请求的MIME类型。例如在发送请求前，设置请求头：

        httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

步骤二：处理服务器端的响应
----------------------------
处理过程在之前定义的响应函数中执行

    httpRequest.onreadystatechange = nameOfTheFunction;
    

1. 检查请求的状态，状态码如下：

        0 (uninitialized)
        1 (loading)
        2 (loaded)
        3 (interactive)
        4 (complete)

    例如： 4表示服务器的响应已经被完全接收了，你可以继续去处理

        if (httpRequest.readyState === 4) {
            // everything is good, the response is received
        } else {
            // still not ready
        }

2. 检查HTTP服务器响应状态码（response code）
   可能的状态码在[W3C site](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)上看的到

    ```
    if (httpRequest.status === 200) {
        // perfect!
    } else {
        // there was a problem with the request,
        // for example the response may contain a 404 (Not Found)
        // or 500 (Internal Server Error) response code
    }
    ```

3. 获取服务器的返回数据
    httpRequest.responseText: 将服务器的响应作为一个文本串返回
    httpRequest.responseXML: 以XMLDocument对象的形式，返回服务器的响应，可以用js的dom方法进行解析
    
    通常用eval来解析。eval函数接收一个参数s，如果s不是字符串，则直接返回s。否则执行s语句。如果s语句执行结果是一个值，则返回此值，否则返回undefined。 
    需要特别注意的是对象声明语法“{}”并不能返回一个值，需要用括号括起来才会返回值

        var code1='"a" + 2'; //表达式 
        varcode2='{a:2}'; //语句 
        alert(eval(code1)); //->'a2' 
        alert(eval(code2)); //->undefined 
        alert(eval('(' + code2 + ')')); //->[object Object] 

    对于对象声明语句来说，仅仅是执行，并不能返回值。为了返回常用的“{}”这样的对象声明语句，必须用括号括住，以将其转换为表达式，才能返回其 值。这也是使用JSON来进行Ajax开发的基本原理之一。


步骤三：一个实例
----------------

```
function fetchCommentList(param, done, fail) {
    _getRemoteData(Stetting.requestPath.getDetailCommentList, param, function(request) {
        if (request.status == 200) {
            var data  = eval("(" + request.response + ")");
            if(!data.code) {
                done(data.data);
            } else {
                console.log(data.msg);
                fail && fail(data);
            }
        } else {
            fail && fail(request);
        }
    });
}

function _getRemoteData(url, params, callback, method) {
    var request = new XMLHttpRequest(),
        requestUrl,
        method = method || "POST";

    params ? params : (params = null);
    if (request == null) {
        alert('没有成功创建请求')
        return;
    }
    if(method == "GET") {
        requestUrl =  url + "/" + params;    
    }
    else {
        requestUrl = url;
    }
    request.open(method,requestUrl,true);
    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    request.onreadystatechange = function(e) {
        if (request.readyState == 4) {
            callback(request);
        } else {
            
        }
    };
    if(method == "POST") {
        request.send(params);
    } else {
        request.send();
    }
}
```

### 参考资料
- [](http://javascript.ruanyifeng.com/bom/ajax.html)


### 状态码

[http://www.aichengxu.com/article/Javascript/701_7.html](http://www.aichengxu.com/article/Javascript/701_7.html)

readyState
HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。

5 个状态中每一个都有一个相关联的非正式的名称，下表列出了状态、名称和含义：

状态  名称  描述
0   Uninitialized   初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。
1   Open    open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。
2   Send    Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。
3   Receiving   所有响应头部都已经接收到。响应体开始接收但未完成。
4   Loaded  HTTP 响应已经完全接收。

readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了 abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 onreadystatechange 事件句柄。

status
由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 "Not Found" 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。


1xx: 信息
消息: 描述:
100 Continue    服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。
101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。
2xx: 成功
消息: 描述:
200 OK  请求成功（其后是对GET和POST请求的应答文档。）
201 Created 请求被创建完成，同时新的资源被创建。
202 Accepted    供处理的请求已被接受，但是处理未完成。
203 Non-authoritative Information   文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。
204 No Content  没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
205 Reset Content   没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。
206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。
3xx: 重定向
消息: 描述:
300 Multiple Choices    多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。
301 Moved Permanently   所请求的页面已经转移至新的url。
302 Found   所请求的页面已经临时转移至新的url。
303 See Other   所请求的页面可在别的url下被找到。
304 Not Modified    未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
305 Use Proxy   客户请求的文档应该通过Location头所指明的代理服务器提取。
306 Unused  此代码被用于前一版本。目前已不再使用，但是代码依然被保留。
307 Temporary Redirect  被请求的页面已经临时移至新的url。
4xx: 客户端错误
消息: 描述:
400 Bad Request 服务器未能理解请求。
401 Unauthorized    被请求的页面需要用户名和密码。
402 Payment Required    此代码尚无法使用。
403 Forbidden   对被请求页面的访问被禁止。
404 Not Found   服务器无法找到被请求的页面。
405 Method Not Allowed  请求中指定的方法不被允许。
406 Not Acceptable  服务器生成的响应无法被客户端所接受。
407 Proxy Authentication Required   用户必须首先使用代理服务器进行验证，这样请求才会被处理。
408 Request Timeout 请求超出了服务器的等待时间。
409 Conflict    由于冲突，请求无法被完成。
410 Gone    被请求的页面不可用。
411 Length Required "Content-Length"未被定义。如果无此内容，服务器不会接受请求。
412 Precondition Failed 请求中的前提条件被服务器评估为失败。
413 Request Entity Too Large    由于所请求的实体的太大，服务器不会接受请求。
414 Request-url Too Long    由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。
415 Unsupported Media Type  由于媒介类型不被支持，服务器不会接受请求。
416 服务器不能满足客户在请求中指定的Range头。
417 Expectation Failed  
5xx: 服务器错误
消息: 描述:
500 Internal Server Error   请求未完成。服务器遇到不可预知的情况。
501 Not Implemented 请求未完成。服务器不支持所请求的功能。
502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。
503 Service Unavailable 请求未完成。服务器临时过载或当机。
504 Gateway Timeout 网关超时。
505 HTTP Version Not Supported  服务器不支持请求中指明的HTTP协议版本。
